<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SF_I2C_SP21: CORE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SF_I2C_SP21
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___c_o_r_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CORE<div class="ingroups"><a class="el" href="group__emlib.html">Emlib</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Core interrupt handling API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadf7237e6f40425caeb2ac56efb97b43b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gadf7237e6f40425caeb2ac56efb97b43b">CORE_ATOMIC_BASE_PRIORITY_LEVEL</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:gadf7237e6f40425caeb2ac56efb97b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3362b0f3a8415dcae958dfda16b8e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a>&#160;&#160;&#160;CORE_ATOMIC_METHOD_PRIMASK</td></tr>
<tr class="separator:ga3a3362b0f3a8415dcae958dfda16b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ec0cf323631243d122be29ed5624c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gae4ec0cf323631243d122be29ed5624c6">CORE_INTERRUPT_ENTRY</a>()</td></tr>
<tr class="separator:gae4ec0cf323631243d122be29ed5624c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672ddcad939a4b922b35204d6a857027"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga672ddcad939a4b922b35204d6a857027">CORE_INTERRUPT_EXIT</a>()</td></tr>
<tr class="separator:ga672ddcad939a4b922b35204d6a857027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga27d5f5d8592e4d6de95a50c44a51ce9f"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga27d5f5d8592e4d6de95a50c44a51ce9f">CORE_CriticalDisableIrq</a> (void)</td></tr>
<tr class="memdesc:ga27d5f5d8592e4d6de95a50c44a51ce9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts.  <a href="group___c_o_r_e.html#ga27d5f5d8592e4d6de95a50c44a51ce9f">More...</a><br /></td></tr>
<tr class="separator:ga27d5f5d8592e4d6de95a50c44a51ce9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b01a782ebe5720b3505c30126c7596"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gad9b01a782ebe5720b3505c30126c7596">CORE_CriticalEnableIrq</a> (void)</td></tr>
<tr class="memdesc:gad9b01a782ebe5720b3505c30126c7596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts.  <a href="group___c_o_r_e.html#gad9b01a782ebe5720b3505c30126c7596">More...</a><br /></td></tr>
<tr class="separator:gad9b01a782ebe5720b3505c30126c7596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420c5e796d60862f374fe02797bc67cc"><td class="memItemLeft" align="right" valign="top">SL_WEAK CORE_irqState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">CORE_EnterCritical</a> (void)</td></tr>
<tr class="memdesc:ga420c5e796d60862f374fe02797bc67cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a CRITICAL section.  <a href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">More...</a><br /></td></tr>
<tr class="separator:ga420c5e796d60862f374fe02797bc67cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3486ed889fc97ae4dcbc840fedb9421"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gae3486ed889fc97ae4dcbc840fedb9421">CORE_ExitCritical</a> (CORE_irqState_t irqState)</td></tr>
<tr class="memdesc:gae3486ed889fc97ae4dcbc840fedb9421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit a CRITICAL section.  <a href="group___c_o_r_e.html#gae3486ed889fc97ae4dcbc840fedb9421">More...</a><br /></td></tr>
<tr class="separator:gae3486ed889fc97ae4dcbc840fedb9421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768aa167717431945535a3677f6c6797"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga768aa167717431945535a3677f6c6797">CORE_YieldCritical</a> (void)</td></tr>
<tr class="memdesc:ga768aa167717431945535a3677f6c6797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brief interrupt enable/disable sequence to allow handling of pending interrupts.  <a href="group___c_o_r_e.html#ga768aa167717431945535a3677f6c6797">More...</a><br /></td></tr>
<tr class="separator:ga768aa167717431945535a3677f6c6797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdfbbd11ed59822d754a25ddd9805b38"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gafdfbbd11ed59822d754a25ddd9805b38">CORE_AtomicDisableIrq</a> (void)</td></tr>
<tr class="memdesc:gafdfbbd11ed59822d754a25ddd9805b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interrupts.  <a href="group___c_o_r_e.html#gafdfbbd11ed59822d754a25ddd9805b38">More...</a><br /></td></tr>
<tr class="separator:gafdfbbd11ed59822d754a25ddd9805b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82849c67cf5d03bf6d9e8b56d3d9008d"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga82849c67cf5d03bf6d9e8b56d3d9008d">CORE_AtomicEnableIrq</a> (void)</td></tr>
<tr class="memdesc:ga82849c67cf5d03bf6d9e8b56d3d9008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable interrupts.  <a href="group___c_o_r_e.html#ga82849c67cf5d03bf6d9e8b56d3d9008d">More...</a><br /></td></tr>
<tr class="separator:ga82849c67cf5d03bf6d9e8b56d3d9008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61bd0aa238e5eed1e725c007755576a5"><td class="memItemLeft" align="right" valign="top">SL_WEAK CORE_irqState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga61bd0aa238e5eed1e725c007755576a5">CORE_EnterAtomic</a> (void)</td></tr>
<tr class="memdesc:ga61bd0aa238e5eed1e725c007755576a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter an ATOMIC section.  <a href="group___c_o_r_e.html#ga61bd0aa238e5eed1e725c007755576a5">More...</a><br /></td></tr>
<tr class="separator:ga61bd0aa238e5eed1e725c007755576a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669cd1707198be603ef5d36605d0d20b"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga669cd1707198be603ef5d36605d0d20b">CORE_ExitAtomic</a> (CORE_irqState_t irqState)</td></tr>
<tr class="memdesc:ga669cd1707198be603ef5d36605d0d20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit an ATOMIC section.  <a href="group___c_o_r_e.html#ga669cd1707198be603ef5d36605d0d20b">More...</a><br /></td></tr>
<tr class="separator:ga669cd1707198be603ef5d36605d0d20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae827216d8f44d661d6ff49a5cf5ce025"><td class="memItemLeft" align="right" valign="top">SL_WEAK void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gae827216d8f44d661d6ff49a5cf5ce025">CORE_YieldAtomic</a> (void)</td></tr>
<tr class="memdesc:gae827216d8f44d661d6ff49a5cf5ce025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brief interrupt enable/disable sequence to allow handling of pending interrupts.  <a href="group___c_o_r_e.html#gae827216d8f44d661d6ff49a5cf5ce025">More...</a><br /></td></tr>
<tr class="separator:gae827216d8f44d661d6ff49a5cf5ce025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga510268c9357cb2cffddd9dd75ddf7fab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga510268c9357cb2cffddd9dd75ddf7fab">CORE_EnterNvicMask</a> (CORE_nvicMask_t *nvicState, const CORE_nvicMask_t *disable)</td></tr>
<tr class="memdesc:ga510268c9357cb2cffddd9dd75ddf7fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a NVIC mask section.  <a href="group___c_o_r_e.html#ga510268c9357cb2cffddd9dd75ddf7fab">More...</a><br /></td></tr>
<tr class="separator:ga510268c9357cb2cffddd9dd75ddf7fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818266df617b6e900b124d30f4cf7db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga818266df617b6e900b124d30f4cf7db4">CORE_NvicDisableMask</a> (const CORE_nvicMask_t *disable)</td></tr>
<tr class="memdesc:ga818266df617b6e900b124d30f4cf7db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable NVIC interrupts.  <a href="group___c_o_r_e.html#ga818266df617b6e900b124d30f4cf7db4">More...</a><br /></td></tr>
<tr class="separator:ga818266df617b6e900b124d30f4cf7db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd594b0671e10977a3655f289439af09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gafd594b0671e10977a3655f289439af09">CORE_NvicEnableMask</a> (const CORE_nvicMask_t *enable)</td></tr>
<tr class="memdesc:gafd594b0671e10977a3655f289439af09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current NVIC interrupt enable mask.  <a href="group___c_o_r_e.html#gafd594b0671e10977a3655f289439af09">More...</a><br /></td></tr>
<tr class="separator:gafd594b0671e10977a3655f289439af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c84177a6c8922b997d9a0bb94ec0ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga3c84177a6c8922b997d9a0bb94ec0ff9">CORE_YieldNvicMask</a> (const CORE_nvicMask_t *enable)</td></tr>
<tr class="memdesc:ga3c84177a6c8922b997d9a0bb94ec0ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brief NVIC interrupt enable/disable sequence to allow handling of pending interrupts.  <a href="group___c_o_r_e.html#ga3c84177a6c8922b997d9a0bb94ec0ff9">More...</a><br /></td></tr>
<tr class="separator:ga3c84177a6c8922b997d9a0bb94ec0ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74cc1f2c3a9c786f1108eba8305b4a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga74cc1f2c3a9c786f1108eba8305b4a02">CORE_NvicMaskSetIRQ</a> (IRQn_Type irqN, CORE_nvicMask_t *mask)</td></tr>
<tr class="memdesc:ga74cc1f2c3a9c786f1108eba8305b4a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to set an IRQn bit in a NVIC enable/disable mask.  <a href="group___c_o_r_e.html#ga74cc1f2c3a9c786f1108eba8305b4a02">More...</a><br /></td></tr>
<tr class="separator:ga74cc1f2c3a9c786f1108eba8305b4a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf82cce035328e4558db771ecfe8720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga9cf82cce035328e4558db771ecfe8720">CORE_NvicMaskClearIRQ</a> (IRQn_Type irqN, CORE_nvicMask_t *mask)</td></tr>
<tr class="memdesc:ga9cf82cce035328e4558db771ecfe8720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to clear an IRQn bit in a NVIC enable/disable mask.  <a href="group___c_o_r_e.html#ga9cf82cce035328e4558db771ecfe8720">More...</a><br /></td></tr>
<tr class="separator:ga9cf82cce035328e4558db771ecfe8720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34622f7414387576c9f16a0ec5770db8"><td class="memItemLeft" align="right" valign="top">SL_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga34622f7414387576c9f16a0ec5770db8">CORE_InIrqContext</a> (void)</td></tr>
<tr class="memdesc:ga34622f7414387576c9f16a0ec5770db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current CPU operation mode is handler mode.  <a href="group___c_o_r_e.html#ga34622f7414387576c9f16a0ec5770db8">More...</a><br /></td></tr>
<tr class="separator:ga34622f7414387576c9f16a0ec5770db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0e48322a9b05fd1d265e55a1c38af8a"><td class="memItemLeft" align="right" valign="top">SL_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gad0e48322a9b05fd1d265e55a1c38af8a">CORE_IrqIsBlocked</a> (IRQn_Type irqN)</td></tr>
<tr class="memdesc:gad0e48322a9b05fd1d265e55a1c38af8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific interrupt is disabled or blocked.  <a href="group___c_o_r_e.html#gad0e48322a9b05fd1d265e55a1c38af8a">More...</a><br /></td></tr>
<tr class="separator:gad0e48322a9b05fd1d265e55a1c38af8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae68b1a852ef2fd42d15dd7d5ee9933"><td class="memItemLeft" align="right" valign="top">SL_WEAK bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gadae68b1a852ef2fd42d15dd7d5ee9933">CORE_IrqIsDisabled</a> (void)</td></tr>
<tr class="memdesc:gadae68b1a852ef2fd42d15dd7d5ee9933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if interrupts are disabled.  <a href="group___c_o_r_e.html#gadae68b1a852ef2fd42d15dd7d5ee9933">More...</a><br /></td></tr>
<tr class="separator:gadae68b1a852ef2fd42d15dd7d5ee9933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa32f111ee6cdd5e854b489a04a79b68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gaaa32f111ee6cdd5e854b489a04a79b68">CORE_GetNvicEnabledMask</a> (CORE_nvicMask_t *mask)</td></tr>
<tr class="memdesc:gaaa32f111ee6cdd5e854b489a04a79b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current NVIC enable mask state.  <a href="group___c_o_r_e.html#gaaa32f111ee6cdd5e854b489a04a79b68">More...</a><br /></td></tr>
<tr class="separator:gaaa32f111ee6cdd5e854b489a04a79b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb9b9a49a92a6857c600cffb4a8b384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gaadb9b9a49a92a6857c600cffb4a8b384">CORE_GetNvicMaskDisableState</a> (const CORE_nvicMask_t *mask)</td></tr>
<tr class="memdesc:gaadb9b9a49a92a6857c600cffb4a8b384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get NVIC disable state for a given mask.  <a href="group___c_o_r_e.html#gaadb9b9a49a92a6857c600cffb4a8b384">More...</a><br /></td></tr>
<tr class="separator:gaadb9b9a49a92a6857c600cffb4a8b384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788fc3ea8bf0a931e5b3c9266a543c25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga788fc3ea8bf0a931e5b3c9266a543c25">CORE_NvicIRQDisabled</a> (IRQn_Type irqN)</td></tr>
<tr class="memdesc:ga788fc3ea8bf0a931e5b3c9266a543c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an NVIC interrupt is disabled.  <a href="group___c_o_r_e.html#ga788fc3ea8bf0a931e5b3c9266a543c25">More...</a><br /></td></tr>
<tr class="separator:ga788fc3ea8bf0a931e5b3c9266a543c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d15689084d8eba1a919b0ccdc163d3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#ga19d15689084d8eba1a919b0ccdc163d3">CORE_GetNvicRamTableHandler</a> (IRQn_Type irqN)</td></tr>
<tr class="memdesc:ga19d15689084d8eba1a919b0ccdc163d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to get the handler for a specific interrupt.  <a href="group___c_o_r_e.html#ga19d15689084d8eba1a919b0ccdc163d3">More...</a><br /></td></tr>
<tr class="separator:ga19d15689084d8eba1a919b0ccdc163d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff18df16b51922db178fed08846f2814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gaff18df16b51922db178fed08846f2814">CORE_SetNvicRamTableHandler</a> (IRQn_Type irqN, void *handler)</td></tr>
<tr class="memdesc:gaff18df16b51922db178fed08846f2814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to set the handler for a specific interrupt.  <a href="group___c_o_r_e.html#gaff18df16b51922db178fed08846f2814">More...</a><br /></td></tr>
<tr class="separator:gaff18df16b51922db178fed08846f2814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8eb75f2f2a86503a47bf96c76ae332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_o_r_e.html#gaea8eb75f2f2a86503a47bf96c76ae332">CORE_InitNvicVectorTable</a> (uint32_t *sourceTable, uint32_t sourceSize, uint32_t *targetTable, uint32_t targetSize, void *defaultHandler, bool overwriteActive)</td></tr>
<tr class="memdesc:gaea8eb75f2f2a86503a47bf96c76ae332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an interrupt vector table by copying table entries from a source to a target table.  <a href="group___c_o_r_e.html#gaea8eb75f2f2a86503a47bf96c76ae332">More...</a><br /></td></tr>
<tr class="separator:gaea8eb75f2f2a86503a47bf96c76ae332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Core interrupt handling API. </p>
<ul>
<li><a class="el" href="group___c_o_r_e.html#core_intro">Introduction</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_conf">Compile-time Configuration</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_macro_api">Macro API</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_reimplementation">API reimplementation</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_vector_tables">Interrupt vector tables</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_examples">Examples</a> </li>
<li><a class="el" href="group___c_o_r_e.html#core_porting">Porting from em_int</a></li>
</ul>
<p><br  />
 </p>
<h1><a class="anchor" id="core_intro"></a>
Introduction</h1>
<p>CORE interrupt API provides a simple and safe means to disable and enable interrupts to protect sections of code.</p>
<p>This is often referred to as "critical sections". This module provides support for three types of critical sections, each with different interrupt blocking capabilities.</p>
<ul>
<li><b>CRITICAL</b> section: Inside a critical section, all interrupts are disabled (except for fault handlers). The PRIMASK register is always used for interrupt disable/enable. </li>
<li><b>ATOMIC</b> section: This type of section is configurable and the default method is to use PRIMASK. With BASEPRI configuration, interrupts with priority equal to or lower than a given configurable level are disabled. The interrupt disable priority level is defined at compile time. The BASEPRI register is not available for all architectures. </li>
<li><b>NVIC mask</b> section: Disable NVIC (external interrupts) on an individual manner.</li>
</ul>
<p>em_core also has an API for manipulating RAM-based interrupt vector tables.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="core_conf"></a>
Compile-time Configuration</h1>
<p>The following #defines  are used to configure em_core: </p><div class="fragment"><div class="line"><span class="comment">// The interrupt priority level used inside ATOMIC sections.</span></div>
<div class="line"><span class="preprocessor">#define CORE_ATOMIC_BASE_PRIORITY_LEVEL    3</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A method used for interrupt disable/enable within ATOMIC sections.</span></div>
<div class="line"><span class="preprocessor">#define CORE_ATOMIC_METHOD                 CORE_ATOMIC_METHOD_PRIMASK</span></div>
</div><!-- fragment --><p>If the default values do not support your needs, they can be overridden by supplying -D compiler flags on the compiler command line or by collecting all macro redefinitions in a file named <em>emlib_config.h</em> and then supplying -DEMLIB_USER_CONFIG on a compiler command line.</p>
<dl class="section note"><dt>Note</dt><dd>The default emlib configuration for ATOMIC section interrupt disable method is using PRIMASK, i.e., ATOMIC sections are implemented as CRITICAL sections.</dd>
<dd>
Due to architectural limitations Cortex-M0+ devices do not support ATOMIC type critical sections using the BASEPRI register. On M0+ devices ATOMIC section helper macros are available but they are implemented as CRITICAL sections using PRIMASK register.</dd></dl>
<p><br  />
 </p>
<h1><a class="anchor" id="core_macro_api"></a>
Macro API</h1>
<p>The primary em_core API is the macro API. Macro API will map to correct CORE functions according to the selected <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> and similar configurations (the full CORE API is of course also available). The most useful macros are as follows:</p>
<p>CORE_DECLARE_IRQ_STATE <br  />
 CORE_ENTER_ATOMIC() <br  />
 @n Used together to implement an ATOMIC section. </p><div class="fragment"><div class="line">{</div>
<div class="line">  CORE_DECLARE_IRQ_STATE;           <span class="comment">// Storage for saving IRQ state prior to</span></div>
<div class="line">                                    <span class="comment">// atomic section entry.</span></div>
<div class="line"> </div>
<div class="line">  CORE_ENTER_ATOMIC();              <span class="comment">// Enter atomic section.</span></div>
<div class="line"> </div>
<div class="line">  ...</div>
<div class="line">  ... your code goes here ...</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  CORE_EXIT_ATOMIC();               <span class="comment">// Exit atomic section, IRQ state is restored.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 @n A concatenation of all three macros above. </p><div class="fragment"><div class="line">{</div>
<div class="line">  CORE_ATOMIC_SECTION(</div>
<div class="line">    ...</div>
<div class="line">    ... your code goes here ...</div>
<div class="line">    ...</div>
<div class="line">  )</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 CORE_DECLARE_IRQ_STATE <br  />
 CORE_ENTER_CRITICAL() <br  />
 CORE_EXIT_CRITICAL() <br  />
 @n These macros implement CRITICAL sections in a similar fashion as described above for ATOMIC sections.</p>
<p><br  />
 CORE_DECLARE_NVIC_STATE <br  />
 CORE_ENTER_NVIC() <br  />
 CORE_EXIT_NVIC() <br  />
 @n These macros implement NVIC mask sections in a similar fashion as described above for ATOMIC sections. See <a class="el" href="group___c_o_r_e.html#core_examples">Examples</a> for an example.</p>
<p>Refer to <em>Macros</em> or <em>Macro Definition Documentation</em> below for a full list of macros.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="core_reimplementation"></a>
API reimplementation</h1>
<p>Most of the functions in the API are implemented as weak functions. This means that it is easy to reimplement when special needs arise. Shown below is a reimplementation of CRITICAL sections suitable if FreeRTOS OS is used: </p><div class="fragment"><div class="line">CORE_irqState_t <a class="code" href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">CORE_EnterCritical</a>(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  vPortEnterCritical();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="group___c_o_r_e.html#gae3486ed889fc97ae4dcbc840fedb9421">CORE_ExitCritical</a>(CORE_irqState_t irqState)</div>
<div class="line">{</div>
<div class="line">  (void)irqState;</div>
<div class="line">  vPortExitCritical();</div>
<div class="line">}</div>
<div class="ttc" id="agroup___c_o_r_e_html_ga420c5e796d60862f374fe02797bc67cc"><div class="ttname"><a href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">CORE_EnterCritical</a></div><div class="ttdeci">SL_WEAK CORE_irqState_t CORE_EnterCritical(void)</div><div class="ttdoc">Enter a CRITICAL section.</div><div class="ttdef"><b>Definition:</b> em_core.c:335</div></div>
<div class="ttc" id="agroup___c_o_r_e_html_gae3486ed889fc97ae4dcbc840fedb9421"><div class="ttname"><a href="group___c_o_r_e.html#gae3486ed889fc97ae4dcbc840fedb9421">CORE_ExitCritical</a></div><div class="ttdeci">SL_WEAK void CORE_ExitCritical(CORE_irqState_t irqState)</div><div class="ttdoc">Exit a CRITICAL section.</div><div class="ttdef"><b>Definition:</b> em_core.c:351</div></div>
</div><!-- fragment --><p> Also note that CORE_Enter/ExitCritical() are not implemented as inline functions. As a result, reimplementations will be possible even when original implementations are inside a linked library.</p>
<p>Some RTOSes must be notified on interrupt handler entry and exit. Macros <a class="el" href="group___c_o_r_e.html#gae4ec0cf323631243d122be29ed5624c6">CORE_INTERRUPT_ENTRY()</a> and <a class="el" href="group___c_o_r_e.html#ga672ddcad939a4b922b35204d6a857027">CORE_INTERRUPT_EXIT()</a> are suitable placeholders for inserting such code. Insert these macros in all your interrupt handlers and then override the default macro implementations. This is an example if uC/OS is used: </p><div class="fragment"><div class="line"><span class="comment">// In emlib_config.h:</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define CORE_INTERRUPT_ENTRY()   OSIntEnter()</span></div>
<div class="line"><span class="preprocessor">#define CORE_INTERRUPT_EXIT()    OSIntExit()</span></div>
</div><!-- fragment --><p><br  />
 </p>
<h1><a class="anchor" id="core_vector_tables"></a>
Interrupt vector tables</h1>
<p>When using RAM based interrupt vector tables it is the user's responsibility to allocate the table space correctly. The tables must be aligned as specified in the CPU reference manual.</p>
<p><a class="el" href="group___c_o_r_e.html#gaea8eb75f2f2a86503a47bf96c76ae332">@n</a> Initialize a RAM based vector table by copying table entries from a source vector table to a target table. VTOR is set to the address of the target vector table.</p>
<p><br  />
 <a class="el" href="group___c_o_r_e.html#ga19d15689084d8eba1a919b0ccdc163d3">CORE_GetNvicRamTableHandler()</a> <br  />
 <a class="el" href="group___c_o_r_e.html#gaff18df16b51922db178fed08846f2814">@n</a> Use these functions to get or set the interrupt handler for a specific IRQn. They both use the interrupt vector table defined by the current VTOR register value.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="core_examples"></a>
Examples</h1>
<p>Implement an NVIC critical section: </p><div class="fragment"><div class="line">{</div>
<div class="line">  CORE_DECLARE_NVIC_ZEROMASK(mask); <span class="comment">// A zero initialized NVIC disable mask</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set mask bits for IRQs to block in the NVIC critical section.</span></div>
<div class="line">  <span class="comment">// In many cases, you can create the disable mask once upon application</span></div>
<div class="line">  <span class="comment">// startup and use the mask globally throughout the application lifetime.</span></div>
<div class="line">  <a class="code" href="group___c_o_r_e.html#ga74cc1f2c3a9c786f1108eba8305b4a02">CORE_NvicMaskSetIRQ</a>(LEUART0_IRQn, &amp;mask);</div>
<div class="line">  <a class="code" href="group___c_o_r_e.html#ga74cc1f2c3a9c786f1108eba8305b4a02">CORE_NvicMaskSetIRQ</a>(VCMP_IRQn,    &amp;mask);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Enter NVIC critical section with the disable mask</span></div>
<div class="line">  CORE_NVIC_SECTION(&amp;mask,</div>
<div class="line">    ...</div>
<div class="line">    ... your code goes here ...</div>
<div class="line">    ...</div>
<div class="line">  )</div>
<div class="line">}</div>
<div class="ttc" id="agroup___c_o_r_e_html_ga74cc1f2c3a9c786f1108eba8305b4a02"><div class="ttname"><a href="group___c_o_r_e.html#ga74cc1f2c3a9c786f1108eba8305b4a02">CORE_NvicMaskSetIRQ</a></div><div class="ttdeci">void CORE_NvicMaskSetIRQ(IRQn_Type irqN, CORE_nvicMask_t *mask)</div><div class="ttdoc">Utility function to set an IRQn bit in a NVIC enable/disable mask.</div><div class="ttdef"><b>Definition:</b> em_core.c:614</div></div>
</div><!-- fragment --><p><br  />
 </p>
<h1><a class="anchor" id="core_porting"></a>
Porting from em_int</h1>
<p>Existing code using INT_Enable() and INT_Disable() must be ported to the em_core API. While em_int used, a global counter to store the interrupt state, em_core uses a local variable. Any usage of INT_Disable(), therefore, needs to be replaced with a declaration of the interrupt state variable before entering the critical section.</p>
<p>Since the state variable is in local scope, the critical section exit needs to occur within the scope of the variable. If multiple nested critical sections are used, each needs to have its own state variable in its own scope.</p>
<p>In many cases, completely disabling all interrupts using CRITICAL sections might be more heavy-handed than needed. When porting, consider whether other types of sections, such as ATOMIC or NVIC mask, can be used to only disable a subset of the interrupts.</p>
<p>Replacing em_int calls with em_core function calls: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// INT_Disable();</span></div>
<div class="line">  CORE_DECLARE_IRQ_STATE;</div>
<div class="line">  CORE_ENTER_ATOMIC();</div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">    .</div>
<div class="line">  <span class="comment">// INT_Enable();</span></div>
<div class="line">  CORE_EXIT_ATOMIC();</div>
<div class="line">}</div>
</div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gadf7237e6f40425caeb2ac56efb97b43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf7237e6f40425caeb2ac56efb97b43b">&#9670;&nbsp;</a></span>CORE_ATOMIC_BASE_PRIORITY_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_ATOMIC_BASE_PRIORITY_LEVEL&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interrupt priority level disabled within ATOMIC regions. Interrupts with priority level equal to or lower than this definition will be disabled within ATOMIC regions. </p>

</div>
</div>
<a id="ga3a3362b0f3a8415dcae958dfda16b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3362b0f3a8415dcae958dfda16b8e2">&#9670;&nbsp;</a></span>CORE_ATOMIC_METHOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_ATOMIC_METHOD&#160;&#160;&#160;CORE_ATOMIC_METHOD_PRIMASK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify which method to use when implementing ATOMIC sections. You can select between BASEPRI or PRIMASK method. </p><dl class="section note"><dt>Note</dt><dd>On Cortex-M0+ devices only PRIMASK can be used. </dd></dl>

</div>
</div>
<a id="gae4ec0cf323631243d122be29ed5624c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ec0cf323631243d122be29ed5624c6">&#9670;&nbsp;</a></span>CORE_INTERRUPT_ENTRY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_INTERRUPT_ENTRY</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for optional interrupt handler entry code. This might be needed when working with an RTOS. </p>

</div>
</div>
<a id="ga672ddcad939a4b922b35204d6a857027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672ddcad939a4b922b35204d6a857027">&#9670;&nbsp;</a></span>CORE_INTERRUPT_EXIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CORE_INTERRUPT_EXIT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Placeholder for optional interrupt handler exit code. This might be needed when working with an RTOS. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafdfbbd11ed59822d754a25ddd9805b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdfbbd11ed59822d754a25ddd9805b38">&#9670;&nbsp;</a></span>CORE_AtomicDisableIrq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_AtomicDisableIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts. </p>
<p>Disable interrupts with a priority lower or equal to <a class="el" href="group___c_o_r_e.html#gadf7237e6f40425caeb2ac56efb97b43b">CORE_ATOMIC_BASE_PRIORITY_LEVEL</a>. Sets core BASEPRI register to CORE_ATOMIC_BASE_PRIORITY_LEVEL.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is CORE_ATOMIC_METHOD_PRIMASK, this function is identical to <a class="el" href="group___c_o_r_e.html#ga27d5f5d8592e4d6de95a50c44a51ce9f">CORE_CriticalDisableIrq()</a>. </dd></dl>

</div>
</div>
<a id="ga82849c67cf5d03bf6d9e8b56d3d9008d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82849c67cf5d03bf6d9e8b56d3d9008d">&#9670;&nbsp;</a></span>CORE_AtomicEnableIrq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_AtomicEnableIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts. </p>
<p>Enable interrupts by setting core BASEPRI register to 0.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is CORE_ATOMIC_METHOD_BASEPRI and PRIMASK is set (CPU is inside a CRITICAL section), interrupts will still be disabled after calling this function.</dd>
<dd>
If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is CORE_ATOMIC_METHOD_PRIMASK, this function is identical to <a class="el" href="group___c_o_r_e.html#gad9b01a782ebe5720b3505c30126c7596">CORE_CriticalEnableIrq()</a>. </dd></dl>

</div>
</div>
<a id="ga27d5f5d8592e4d6de95a50c44a51ce9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27d5f5d8592e4d6de95a50c44a51ce9f">&#9670;&nbsp;</a></span>CORE_CriticalDisableIrq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_CriticalDisableIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable interrupts. </p>
<p>Disable all interrupts by setting PRIMASK. (Fault exception handlers will still be enabled). </p>

</div>
</div>
<a id="gad9b01a782ebe5720b3505c30126c7596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b01a782ebe5720b3505c30126c7596">&#9670;&nbsp;</a></span>CORE_CriticalEnableIrq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_CriticalEnableIrq </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable interrupts. </p>
<p>Enable interrupts by clearing PRIMASK. </p>

</div>
</div>
<a id="ga61bd0aa238e5eed1e725c007755576a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61bd0aa238e5eed1e725c007755576a5">&#9670;&nbsp;</a></span>CORE_EnterAtomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK CORE_irqState_t CORE_EnterAtomic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter an ATOMIC section. </p>
<p>When an ATOMIC section is entered, interrupts with priority lower or equal to <a class="el" href="group___c_o_r_e.html#gadf7237e6f40425caeb2ac56efb97b43b">CORE_ATOMIC_BASE_PRIORITY_LEVEL</a> are disabled.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is CORE_ATOMIC_METHOD_PRIMASK, this function is identical to <a class="el" href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">CORE_EnterCritical()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The value of BASEPRI register prior to ATOMIC section entry. </dd></dl>

</div>
</div>
<a id="ga420c5e796d60862f374fe02797bc67cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420c5e796d60862f374fe02797bc67cc">&#9670;&nbsp;</a></span>CORE_EnterCritical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK CORE_irqState_t CORE_EnterCritical </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a CRITICAL section. </p>
<p>When a CRITICAL section is entered, all interrupts (except fault handlers) are disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of PRIMASK register prior to the CRITICAL section entry. </dd></dl>

</div>
</div>
<a id="ga510268c9357cb2cffddd9dd75ddf7fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga510268c9357cb2cffddd9dd75ddf7fab">&#9670;&nbsp;</a></span>CORE_EnterNvicMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_EnterNvicMask </td>
          <td>(</td>
          <td class="paramtype">CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>nvicState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>disable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a NVIC mask section. </p>
<p>When a NVIC mask section is entered, specified NVIC interrupts are disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nvicState</td><td>Return NVIC interrupts enable mask prior to section entry.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disable</td><td>A mask specifying which NVIC interrupts to disable within the section. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga669cd1707198be603ef5d36605d0d20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga669cd1707198be603ef5d36605d0d20b">&#9670;&nbsp;</a></span>CORE_ExitAtomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_ExitAtomic </td>
          <td>(</td>
          <td class="paramtype">CORE_irqState_t&#160;</td>
          <td class="paramname"><em>irqState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit an ATOMIC section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqState</td><td>The interrupt priority blocking level to restore to BASEPRI when exiting the ATOMIC section. This value is usually the one returned by a prior call to <a class="el" href="group___c_o_r_e.html#ga61bd0aa238e5eed1e725c007755576a5">CORE_EnterAtomic()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is set to CORE_ATOMIC_METHOD_PRIMASK, this function is identical to <a class="el" href="group___c_o_r_e.html#gae3486ed889fc97ae4dcbc840fedb9421">CORE_ExitCritical()</a>. </dd></dl>

</div>
</div>
<a id="gae3486ed889fc97ae4dcbc840fedb9421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3486ed889fc97ae4dcbc840fedb9421">&#9670;&nbsp;</a></span>CORE_ExitCritical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_ExitCritical </td>
          <td>(</td>
          <td class="paramtype">CORE_irqState_t&#160;</td>
          <td class="paramname"><em>irqState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit a CRITICAL section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqState</td><td>The interrupt priority blocking level to restore to PRIMASK when exiting the CRITICAL section. This value is usually the one returned by a prior call to <a class="el" href="group___c_o_r_e.html#ga420c5e796d60862f374fe02797bc67cc">CORE_EnterCritical()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa32f111ee6cdd5e854b489a04a79b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa32f111ee6cdd5e854b489a04a79b68">&#9670;&nbsp;</a></span>CORE_GetNvicEnabledMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_GetNvicEnabledMask </td>
          <td>(</td>
          <td class="paramtype">CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current NVIC enable mask state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mask</td><td>The current NVIC enable mask. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadb9b9a49a92a6857c600cffb4a8b384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadb9b9a49a92a6857c600cffb4a8b384">&#9670;&nbsp;</a></span>CORE_GetNvicMaskDisableState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CORE_GetNvicMaskDisableState </td>
          <td>(</td>
          <td class="paramtype">const CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get NVIC disable state for a given mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>An NVIC mask to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all NVIC interrupt mask bits are clear. </dd></dl>

</div>
</div>
<a id="ga19d15689084d8eba1a919b0ccdc163d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d15689084d8eba1a919b0ccdc163d3">&#9670;&nbsp;</a></span>CORE_GetNvicRamTableHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CORE_GetNvicRamTableHandler </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to get the handler for a specific interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler address.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Uses the interrupt vector table defined by the current VTOR register value. </dd></dl>

</div>
</div>
<a id="ga34622f7414387576c9f16a0ec5770db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34622f7414387576c9f16a0ec5770db8">&#9670;&nbsp;</a></span>CORE_InIrqContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK bool CORE_InIrqContext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the current CPU operation mode is handler mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the CPU is in handler mode (currently executing an interrupt handler). <br  />
 False if the CPU is in thread mode. </dd></dl>

</div>
</div>
<a id="gaea8eb75f2f2a86503a47bf96c76ae332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea8eb75f2f2a86503a47bf96c76ae332">&#9670;&nbsp;</a></span>CORE_InitNvicVectorTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_InitNvicVectorTable </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sourceTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sourceSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>targetTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>defaultHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwriteActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an interrupt vector table by copying table entries from a source to a target table. </p>
<dl class="section note"><dt>Note</dt><dd>This function will set a new VTOR register value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceTable</td><td>The address of the source vector table.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceSize</td><td>A number of entries in the source vector table.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetTable</td><td>The address of the target (new) vector table.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targetSize</td><td>A number of entries in the target vector table.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultHandler</td><td>An address of the interrupt handler used for target entries for which where there is no corresponding source entry (i.e., the target table is larger than the source table).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overwriteActive</td><td>When true, a target table entry is always overwritten with the corresponding source entry. If false, a target table entry is only overwritten if it is zero. This makes it possible for an application to partly initialize a target table before passing it to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0e48322a9b05fd1d265e55a1c38af8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0e48322a9b05fd1d265e55a1c38af8a">&#9670;&nbsp;</a></span>CORE_IrqIsBlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK bool CORE_IrqIsBlocked </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a specific interrupt is disabled or blocked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the interrupt is disabled or blocked. </dd></dl>

</div>
</div>
<a id="gadae68b1a852ef2fd42d15dd7d5ee9933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae68b1a852ef2fd42d15dd7d5ee9933">&#9670;&nbsp;</a></span>CORE_IrqIsDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK bool CORE_IrqIsDisabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if interrupts are disabled. </p>
<dl class="section return"><dt>Returns</dt><dd>True if interrupts are disabled. </dd></dl>

</div>
</div>
<a id="ga818266df617b6e900b124d30f4cf7db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818266df617b6e900b124d30f4cf7db4">&#9670;&nbsp;</a></span>CORE_NvicDisableMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_NvicDisableMask </td>
          <td>(</td>
          <td class="paramtype">const CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>disable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable NVIC interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">disable</td><td>A mask specifying which NVIC interrupts to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd594b0671e10977a3655f289439af09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd594b0671e10977a3655f289439af09">&#9670;&nbsp;</a></span>CORE_NvicEnableMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_NvicEnableMask </td>
          <td>(</td>
          <td class="paramtype">const CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current NVIC interrupt enable mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">enable</td><td>A mask specifying which NVIC interrupts are currently enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga788fc3ea8bf0a931e5b3c9266a543c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga788fc3ea8bf0a931e5b3c9266a543c25">&#9670;&nbsp;</a></span>CORE_NvicIRQDisabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CORE_NvicIRQDisabled </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an NVIC interrupt is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the interrupt is disabled. </dd></dl>

</div>
</div>
<a id="ga9cf82cce035328e4558db771ecfe8720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cf82cce035328e4558db771ecfe8720">&#9670;&nbsp;</a></span>CORE_NvicMaskClearIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_NvicMaskClearIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to clear an IRQn bit in a NVIC enable/disable mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mask</td><td>The mask to clear the interrupt bit in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74cc1f2c3a9c786f1108eba8305b4a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74cc1f2c3a9c786f1108eba8305b4a02">&#9670;&nbsp;</a></span>CORE_NvicMaskSetIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_NvicMaskSetIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to set an IRQn bit in a NVIC enable/disable mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mask</td><td>The mask to set the interrupt bit in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff18df16b51922db178fed08846f2814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff18df16b51922db178fed08846f2814">&#9670;&nbsp;</a></span>CORE_SetNvicRamTableHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_SetNvicRamTableHandler </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>irqN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to set the handler for a specific interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">irqN</td><td>The IRQn_Type enumerator for the interrupt.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The handler address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses the interrupt vector table defined by the current VTOR register value. </dd></dl>

</div>
</div>
<a id="gae827216d8f44d661d6ff49a5cf5ce025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae827216d8f44d661d6ff49a5cf5ce025">&#9670;&nbsp;</a></span>CORE_YieldAtomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_YieldAtomic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brief interrupt enable/disable sequence to allow handling of pending interrupts. </p>
<dl class="section note"><dt>Note</dt><dd>Usully used within an ATOMIC section.</dd>
<dd>
If <a class="el" href="group___c_o_r_e.html#ga3a3362b0f3a8415dcae958dfda16b8e2">CORE_ATOMIC_METHOD</a> is CORE_ATOMIC_METHOD_PRIMASK, this function is identical to <a class="el" href="group___c_o_r_e.html#ga768aa167717431945535a3677f6c6797">CORE_YieldCritical()</a>. </dd></dl>

</div>
</div>
<a id="ga768aa167717431945535a3677f6c6797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768aa167717431945535a3677f6c6797">&#9670;&nbsp;</a></span>CORE_YieldCritical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SL_WEAK void CORE_YieldCritical </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brief interrupt enable/disable sequence to allow handling of pending interrupts. </p>
<dl class="section note"><dt>Note</dt><dd>Usually used within a CRITICAL section. </dd></dl>

</div>
</div>
<a id="ga3c84177a6c8922b997d9a0bb94ec0ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c84177a6c8922b997d9a0bb94ec0ff9">&#9670;&nbsp;</a></span>CORE_YieldNvicMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CORE_YieldNvicMask </td>
          <td>(</td>
          <td class="paramtype">const CORE_nvicMask_t *&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brief NVIC interrupt enable/disable sequence to allow handling of pending interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>A mask specifying which NVIC interrupts to briefly enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usually used within an NVIC mask section. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
